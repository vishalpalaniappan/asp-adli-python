DRAFT [have not proof read yet, will iterate and improve structure]

Software systems are the realization of an intentional design. This means that the relationship between every abstraction in the system is established through the design. The programming language used to implement the design must have the ability to realize the intentions of each abstraction and establish the necessary relationships between the abstractions to realize the design. On a low level, this means being able to implement the intention in the design through lower level abstractions, control flow, loops etc. On a higher level, it means respecting the relationship between higher level abstractions by shaping how data and intention is moved between them. Ultimately, the successful operation of a software system hinges on the ability to realize the intentions of its design in the environment that it is operating in.

Debugging a software system is about understanding how the system was unable to realize the intentions of its design and understanding how to realign its reality with its intention. For example, if a system intends to use the first letter of a book’s name to place it on the shelf, then there is a constraint in the design's semantics that it cannot accept a book with no name. Violating this constraint (the root cause of failure) will result in a predictable failure modality in this intentional world that was designed. In this sense, the design establishes the failure modalities through the constraints placed on the abstractions. The failure is predictable because the semantics specify the conditions under which they will happen and how to prevent it from happening.

Since the abstractions in the design are realized through the abstraction of the programming language, the dynamic trace is a unique kind of diagnostic data. It allows you to directly overlay the intentions of each abstraction with the reality of what happened. Through instrumentation, it becomes possible to describe the design semantics of each abstraction and the reality of what occurred. For example this includes, the intention that each design is trying to achieve, the relationship between the abstractions in the design (order, hierarchy), the constraints that must be respected to preserve the intentions of the design, the known failure modalities that result from this constraint violation etc. This means that through instrumentation of the design semantics and validation of the constraints using the data from the execution, it is possible to identify the root cause of failure and the steps that must be taken to prevent this failure modality. Ultimately, this process automates debugging.

This means that when observing a lossless dynamic trace that has been instrumented with the design semantics, if there is any ambiguity in what is being observed, this implies that the instrumentation of the design semantics is incomplete. It completes the picture by describing the execution through all the abstractions in the design. This means that a lack of understanding doesn’t end in confusion, it highlights specific information that was not instrumented to explain what is being observed. If you are unable to understand the root cause of failure, then you haven’t instrumented the observed failure modality and the constraints that prevent it from happening.

This process ensures that the design is implemented faithfully. However, failures in a software system don’t occur only because of failure to enforce the design semantics. They can also occur because of the way the design behaves in a particular environment. If a particular kind of render job fails when it is assigned to a machine with particular specifications, then the environment places a new constraint on the design and a failure to respect this constraint would be a behavioral bug.

A car can be well designed and implemented but it takes a skilled driver to navigate the uncertainty of the road to get it from point A to point B. In this sense, we first ensure the integrity of the design and then we ensure the integrity of the design's behavior in this environment. To do this, we build a behavioral map of the design which captures a full audit of the design's reality. This map provides feedback for how to shape the design to ensure its integrity in this environment. 

The efficacy of a behavioral map is determined by how lossless its information is. If every single aspect of its reality is fully audited, then it becomes possible to automatically manage the software system because management simply becomes a process of enforcing what the behavioral map automatically reveals. However, to do this, we must make it practical to retain all the information that describes the behavioral map. Since the data generated by a dynamic trace is unambiguous in identity and structure (through instrumentation), it becomes possible to apply domain specific compression to the data to minimize its size and maximize its structure. In the process, it also enables a structured way to describe the behavior of the system because it reduces the entropy of the data by describing them through dictionaries. To make this practical, a tool like CLP can be leveraged to apply domain specific to the data and manage the compressed traces while building the behavioral map.

Through this process of instrumenting the dynamic trace with the design semantics and using the trace to build a behavioral map of the design's interaction with the environment, it becomes possible to instrument every realizable failure modality and the constraints that prevent them from happening. Ultimately, this process automates the management of software systems by eliminating any ambiguity in how to ensure that the designs intentions and reality stay aligned. 
